import { createClient } from '@/lib/supabase/client';

export interface Purchase {
  id?: string; // Auto-generated UUID by Supabase
  user_id: string;
  course_id: string;
  payment_id: string; // From Mercado Pago
  status: string; // e.g., 'approved', 'pending', 'failed'
  purchase_date?: string; // Auto-generated by DB (DEFAULT now())
  amount: number;
  created_at?: string; // Auto-generated by DB (DEFAULT now())
}

export async function createPurchaseRecord(
  userId: string,
  courseId: string,
  paymentId: string,
  paymentStatus: string,
  amount: number
): Promise<{
  data: Purchase | null;
  error: { message: string; details?: any; duplicate?: boolean } | null;
}> {
  const supabase = createClient();

  // 1. Check if a purchase record with the same payment_id already exists
  const { data: existingPurchase, error: selectError } = await supabase
    .from('purchases')
    .select('*')
    .eq('payment_id', paymentId)
    .maybeSingle(); // Use maybeSingle as it might not exist

  if (selectError) {
    console.error('Supabase error checking for existing purchase:', selectError);
    // Proceed with insert attempt but log this error. If insert fails due to unique constraint, it will be caught.
  }

  if (existingPurchase) {
    console.log(`Purchase record with payment_id ${paymentId} already exists. Skipping creation.`);
    // Optionally, you could update the existing record if status changed, e.g. from pending to approved.
    // For now, just return it.
    return { data: existingPurchase as Purchase, error: { message: "Duplicate payment ID.", duplicate: true } };
  }

  // 2. Insert new purchase record
  const purchaseData: Omit<Purchase, 'id' | 'purchase_date' | 'created_at'> = {
    user_id: userId,
    course_id: courseId,
    payment_id: paymentId,
    status: paymentStatus,
    amount: amount,
  };

  const { data: newPurchase, error: insertError } = await supabase
    .from('purchases')
    .insert(purchaseData)
    .select() // Return the inserted row
    .single(); // Expecting a single row to be inserted and returned

  if (insertError) {
    console.error('Supabase error creating purchase record:', insertError);
    // Check if the error is due to a unique constraint violation on payment_id, 
    // which might happen in a race condition if the previous check didn't catch it.
    if (insertError.code === '23505') { // PostgreSQL unique violation error code
        console.warn(`Race condition: Purchase with payment_id ${paymentId} likely inserted between check and insert.`);
        // Attempt to fetch the record again, as it should exist now.
        const { data: raceConditionPurchase, error: raceSelectError } = await supabase
            .from('purchases')
            .select('*')
            .eq('payment_id', paymentId)
            .single(); // Should exist
        if (raceConditionPurchase && !raceSelectError) {
            return { data: raceConditionPurchase as Purchase, error: { message: "Duplicate payment ID due to race condition.", duplicate: true } };
        }
        return { data: null, error: { message: "Failed to create purchase due to unique constraint, and couldn't fetch existing.", details: insertError } };
    }
    return { data: null, error: { message: insertError.message, details: insertError } };
  }

  return { data: newPurchase as Purchase, error: null };
}
